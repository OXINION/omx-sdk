/**
 * Jest tests for @omx-sdk/core
 */

import { CoreAuth } from '../src/core';
import { 
  InvalidCredentialsError, 
  NetworkError, 
  ConfigurationError,
  TokenExpiredError 
} from '../src/errors';
import { AuthConfig } from '../src/types';

// Mock Supabase
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    rpc: jest.fn(),
  })),
}));

describe('CoreAuth', () => {
  const validConfig: AuthConfig = {
    clientId: 'test-client-id',
    secretKey: 'test-secret-key',
    supabaseUrl: 'https://test.supabase.co',
    supabaseAnonKey: 'test-anon-key',
  };

  describe('Configuration Validation', () => {
    it('should accept valid configuration', () => {
      expect(() => new CoreAuth(validConfig)).not.toThrow();
    });

    it('should throw ConfigurationError for missing clientId', () => {
      const config = { ...validConfig };
      delete (config as any).clientId;
      
      expect(() => new CoreAuth(config)).toThrow(ConfigurationError);
    });

    it('should throw ConfigurationError for invalid supabaseUrl', () => {
      const config = { ...validConfig, supabaseUrl: 'not-a-url' };
      
      expect(() => new CoreAuth(config)).toThrow(ConfigurationError);
    });
  });

  describe('Token Management', () => {
    let auth: CoreAuth;
    let mockSupabase: any;

    beforeEach(() => {
      const { createClient } = require('@supabase/supabase-js');
      mockSupabase = {
        rpc: jest.fn(),
      };
      createClient.mockReturnValue(mockSupabase);
      
      auth = new CoreAuth(validConfig);
    });

    afterEach(() => {
      auth.dispose();
      jest.clearAllMocks();
    });

    it('should fetch and cache JWT token', async () => {
      const mockTokenResponse = {
        access_token: 'mock-jwt-token',
        token_type: 'Bearer',
        expires_in: 3600,
      };

      mockSupabase.rpc.mockResolvedValue({
        data: mockTokenResponse,
        error: null,
      });

      const token = await auth.getToken();
      
      expect(token).toBe('mock-jwt-token');
      expect(mockSupabase.rpc).toHaveBeenCalledWith('create_jwt_token', {
        client_id: 'test-client-id',
        secret_key: 'test-secret-key',
      });
    });

    it('should use cached token on subsequent calls', async () => {
      const mockTokenResponse = {
        access_token: 'mock-jwt-token',
        token_type: 'Bearer',
        expires_in: 3600,
      };

      mockSupabase.rpc.mockResolvedValue({
        data: mockTokenResponse,
        error: null,
      });

      // First call - should fetch token
      await auth.getToken();
      
      // Second call - should use cache
      await auth.getToken();
      
      expect(mockSupabase.rpc).toHaveBeenCalledTimes(1);
    });

    it('should force refresh when requested', async () => {
      const mockTokenResponse = {
        access_token: 'mock-jwt-token',
        token_type: 'Bearer',
        expires_in: 3600,
      };

      mockSupabase.rpc.mockResolvedValue({
        data: mockTokenResponse,
        error: null,
      });

      // First call
      await auth.getToken();
      
      // Force refresh
      await auth.getToken(true);
      
      expect(mockSupabase.rpc).toHaveBeenCalledTimes(2);
    });

    it('should handle invalid credentials error', async () => {
      mockSupabase.rpc.mockResolvedValue({
        data: null,
        error: {
          code: 'PGRST301',
          message: 'Invalid client credentials',
        },
      });

      await expect(auth.getToken()).rejects.toThrow(InvalidCredentialsError);
    });
  });

  describe('API Requests', () => {
    let auth: CoreAuth;
    let mockSupabase: any;

    beforeEach(() => {
      const { createClient } = require('@supabase/supabase-js');
      mockSupabase = {
        rpc: jest.fn(),
      };
      createClient.mockReturnValue(mockSupabase);
      
      auth = new CoreAuth(validConfig);

      // Mock successful token response
      mockSupabase.rpc.mockResolvedValue({
        data: {
          access_token: 'mock-jwt-token',
          token_type: 'Bearer',
          expires_in: 3600,
        },
        error: null,
      });
    });

    afterEach(() => {
      auth.dispose();
      jest.clearAllMocks();
    });

    it('should make authenticated GET request', async () => {
      // Mock fetch
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers(),
        json: () => Promise.resolve({ data: 'test' }),
        text: () => Promise.resolve('{"data": "test"}'),
      }) as jest.Mock;

      const response = await auth.makeAuthenticatedRequest('https://api.test.com/data');
      
      expect(response.success).toBe(true);
      expect(response.data).toEqual({ data: 'test' });
      expect(fetch).toHaveBeenCalledWith(
        'https://api.test.com/data',
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            'Authorization': 'Bearer mock-jwt-token',
          }),
        })
      );
    });

    it('should make authenticated POST request with body', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        status: 201,
        headers: new Headers(),
        json: () => Promise.resolve({ id: 123 }),
        text: () => Promise.resolve('{"id": 123}'),
      }) as jest.Mock;

      const requestBody = { name: 'Test User' };
      const response = await auth.makeAuthenticatedRequest('https://api.test.com/users', {
        method: 'POST',
        body: requestBody,
      });
      
      expect(response.success).toBe(true);
      expect(response.data).toEqual({ id: 123 });
      expect(fetch).toHaveBeenCalledWith(
        'https://api.test.com/users',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify(requestBody),
          headers: expect.objectContaining({
            'Authorization': 'Bearer mock-jwt-token',
            'Content-Type': 'application/json',
          }),
        })
      );
    });

    it('should handle 401 response and clear token', async () => {
      global.fetch = jest.fn().mockResolvedValue({
        ok: false,
        status: 401,
        headers: new Headers(),
        text: () => Promise.resolve('Unauthorized'),
      }) as jest.Mock;

      const response = await auth.makeAuthenticatedRequest('https://api.test.com/protected');
      
      expect(response.success).toBe(false);
      expect(response.error?.code).toBe('HTTP_401');
      
      // Token should be cleared
      const tokenInfo = auth.getTokenInfo();
      expect(tokenInfo.isValid).toBe(false);
    });
  });

  describe('Token Info', () => {
    let auth: CoreAuth;

    beforeEach(() => {
      auth = new CoreAuth(validConfig);
    });

    afterEach(() => {
      auth.dispose();
    });

    it('should return correct token info when no token cached', () => {
      const info = auth.getTokenInfo();
      
      expect(info.isValid).toBe(false);
      expect(info.expiresAt).toBeNull();
      expect(info.cachedAt).toBeNull();
    });

    it('should clear token correctly', () => {
      auth.clearToken();
      
      const info = auth.getTokenInfo();
      expect(info.isValid).toBe(false);
    });
  });

  describe('Configuration Updates', () => {
    let auth: CoreAuth;

    beforeEach(() => {
      auth = new CoreAuth(validConfig);
    });

    afterEach(() => {
      auth.dispose();
    });

    it('should update configuration and clear cached token', () => {
      // Cache a token first (mock scenario)
      auth.clearToken(); // Ensure clean state
      
      auth.updateConfig({
        clientId: 'new-client-id',
      });
      
      // Token should be cleared after config update
      const info = auth.getTokenInfo();
      expect(info.isValid).toBe(false);
    });
  });
});
